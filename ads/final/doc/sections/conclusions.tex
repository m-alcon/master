\section{Conclusions}
The difference in the results between the paper's experiments and mine is so huge. Maybe I did not understand the paper correctly, or maybe my implementation is poor compared with theirs. While they are obtaining 0.88 of accuracy with a 3-times speed-up with respect to the \textit{KD-tree} search, I obtained 0.6 of accuracy with 1.1693-times speed-up. Since I am using synthetic high-dimensional data, I should obtain even better results than them, which is not happening. In the paper, they mention that with a standard \textit{KD-tree} they obtain a 0.75 accuracy searching with a limit of 1000 searched nodes. I made a small experiment to test it, and in my case this accuracy is 0.04. As far as I know, searching only 1000 nodes over 20000 is just too few to obtain that high accuracy. Maybe they are searching for points that the tree contains, which is not what I am doing, so the algorithm can find it exactly and stop faster, but they do not let it clear in the paper. It can also be that their search algorithm cuts better the tree branches, so it needs to explore fewer nodes. But it should not be a problem for the \textit{RKD-tree} search because its algorithm does not cut branches itself, it uses the priority queue to select the best node among all trees.  However, if things showed in the paper are correct, \textit{NKD-trees}, \textit{RKD-trees} and \textit{PKD-trees} represent high improvements with respect with the standard \textit{KD-trees}.

As a final and personal conclusion, it was very challenging, and especially satisfactory, to implement the \textit{KD-tree} class and then use it to implement the \textit{RKD-tree} class. In order to extend this work, I would want to find the problem of my implementation, but also it would be interesting to parallelize the search algorithm of the \textit{RKD-tree}, which it should not be so difficult, to see how much it improves.